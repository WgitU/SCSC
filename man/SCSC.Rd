% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SCSC_main.R
\name{SCSC}
\alias{SCSC}
\title{Simultaneous subject and cell clustering for single cell expression count data}
\usage{
SCSC(
  count_data_matr,
  vec_ncell_subj,
  celltype_upb,
  subgroup_upb,
  warm_cluster_label_init = FALSE,
  con_para_nu = 0.1,
  con_para_gamma = 0.1,
  num_iterations = 10000,
  num_burnin = floor(num_iterations/2),
  collect_post_sample = FALSE,
  hyperparameters = c(1, 5, 0.15, 0.15, 1, 1, 2, -2, 0.01, 0.01),
  scaling_factor_est = FALSE,
  print_label = FALSE,
  seed = 1,
  num_threads = 1,
  print_per_iteration = 1000
)
}
\arguments{
\item{count_data_matr}{the expression count data matrix, where rows represent genes and columns represent cells. Noteworthy, the columns need to be ordered based on each cellâ€™s subject information. Specifically, cells of subject 1 correspond to columns 1 to vec_ncell_subj[1], cells of subject 2 match columns (vec_ncell_subj[1]+1):(vec_ncell_subj[1]+vec_ncell_subj[2]) , and so on so forth. The vector vec_ncell_subj is specified next.}

\item{vec_ncell_subj}{an integer vector, in which element i is the total cell number of subject i.}

\item{celltype_upb}{an integer, denoting an upper bound of the cell type number.}

\item{subgroup_upb}{an integer, denoting an upper bound of the subject subgroup number.}

\item{warm_cluster_label_init}{the initialization of cluster labels is random or based on k-means. The default is FALSE, corresponding to the random initialization.}

\item{con_para_nu}{the concentration parameter \eqn{\nu} in NDP used to generate subject subgroup proportions. The default is 0.1.}

\item{con_para_gamma}{the concentration parameter \eqn{\gamma} in NDP used to generate cell type proportions. The default is 0.1.}

\item{num_iterations}{the number of Gibbs sampler iterations. The default is 10000.}

\item{num_burnin}{the number of iterations in burn-in, after which the posterior samples are used to estimate the unknown parameters. The default is the first half of total iterations.}

\item{collect_post_sample}{collect the posterior samples or not. If users are only interested in the estimates, set it as FALSE to save the memory. If users would like to use posterior samples o construct credible intervals or for other uses, set it as TRUE. The default is FALSE.}

\item{hyperparameters}{a vector, which indicates 10 hyper-parameters in the priors or proposal distributions. The first element is the standard deviation of the normal proposal distribution for \eqn{\theta} in the MH step. The second element is an integer representing the radius of the discrete uniform proposal distribution for latent count in the MH step. The third element represents the standard deviation of the normal proposal distribution for the coefficient \eqn{\lambda_0}, while the fourth element is the standard deviation of the normal proposal distribution for \eqn{\lambda_1}. The fifth and sixth elements are the shape parameters of the beta proposal distribution for \eqn{\xi'}, respectively. The seventh and eighth elements correspond to the means of the normal priors for \eqn{\lambda_0} and \eqn{\lambda_1}. The remaining two elements are, respectively, the variances of the normal priors for \eqn{\lambda_0} and \eqn{\lambda_1}. The default is 1, 5, 0.15, 0.15, 1, 1, 2, -2, 0.01, 0.01.}

\item{scaling_factor_est}{estimate the scaling factors for cells or not. The default is FALSE, which fixes all scaling factors at one.}

\item{print_label}{whether or not to print summarized cell type label and subject subgroup label information after each iteration. The default is FALSE.}

\item{seed}{set seed to reproduce results. The default is 1.}

\item{num_threads}{the number of threads generated in the parallel computing. The default is 1.}

\item{print_per_iteration}{how many iterations to print the iteration information when print_label is FALSE. The default is 1000.}
}
\value{
SCSC returns an R list including the following information.
\item{subject_subgroup_label}{a vector, indicating the estimated subgroup labels for each subject.}
\item{cell_type_label}{a vector, indicating the estimated cell types for each cell.}
\item{subject_subgroup_effects}{a matrix of subjectsubgroup effects, in which rows are genes and columns correspond to subject subgroups. Note that the first column is a zero vector because the first subgroup is treated as the reference subgroup, where there is no subject subgroup effect.}
\item{cell_type_effects}{a matrix of cell type effects, in which rows are genes and columns correspond to cell types.}
\item{cell_type_prop}{a matrix of cell type proportions for each subject subgroup, in which rows are cell types and columns are subject subgroups. Specifically, cell_type_prop[k, \eqn{\ell}] is the cell type k proportion of subject subgroup \eqn{\ell}.}
\item{sigma_sq}{a vector, the estimated expression variances for each gene.}
\item{lam0}{a vector, the estimated lambda0 for each gene.}
\item{lam1}{a vector, the estimated lambda1 for each gene.}
\item{alpha}{a scalar, denoting the estimated concentration parameter \eqn{\alpha} in DP at the top level.}
\item{subject_subgroup_prop}{a vector denoting the estimated subject subgroup proportions.}
\item{subject_subgroup_effects_post}{collected posterior samples of subject_subgroup_effects when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{cell_type_effects_post}{collected posterior samples of cell_type_effects when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{sigma_sq_post}{collected posterior samples of sigma_sq when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{lam0_post}{collected posterior samples of lam0 when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{lam1_post}{collected posterior samples of lam1 when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{alpha_post}{collected posterior samples of alpha when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{subject_subgroup_prop_post}{collected posterior samples of subject_subgroup_prop when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
}
\description{
The function SCSC implements a nonparametric Bayesian model for simultaneous subject subgroup discovery and cell type detection based on the scRNA-seq data from multiple subjects. It does not need to prespecify the exact subject subgroup number or cell type number but only their upper bounds, and automatically induces subject subgroup structures and matches cell types across subjects. SCSC is directly applied to the scRNA-seq raw count data because it deliberately considers the data's dropouts, library sizes, and over-dispersion.  In SCSC, a blocked Gibbs sampler is carried out for Bayesian posterior inference.
}
\examples{
library(SCSC)

#import example data
data(example_data)

#gene number
nrow(count_data_matr)

#cell number
ncol(count_data_matr)

#subject number
length(vec_ncell_subj)

#run SCSC
t1 <- Sys.time()
Result <- SCSC(count_data_matr, vec_ncell_subj, celltype_upb = 10, subgroup_upb = 10,
      seed = 1, num_threads = 10, num_iterations = 1000, print_label = TRUE)
t2 <- Sys.time()

#time cost
print(t2 - t1)

#Compared with true subject subgroup labels
table(Result$subject_subgroup_label, subject_subgroup_label_truth)

#Compared with true cell type labels
cell_table <- table(Result$cell_type_label, cell_type_label_truth)
cell_table

#The following shows the summary of the absolute errors across genes within each subject subgroup
summary(abs(Result$subject_subgroup_effects - subject_subgroup_effects_truth))

#The following shows the summary of the absolute errors across genes within each cell type
type_name <- rownames(which(cell_table > 0,TRUE))
cell_unique <- unique(Result$cell_type_label)
summary(abs(Result$cell_type_effects[,c(which(type_name[1]==cell_unique)
            ,which(type_name[2]==cell_unique), which(type_name[3]==cell_unique))]
             - cell_type_effects_truth))

}
\references{
Qiuyu Wu, and Xiangyu Luo. "Nonparametric Bayesian Two-Level Clustering for Subject-Level Single-Cell Expression Data." Statistica Sinica. DOI: 10.5705/ss.202020.0337
}
